# The Graphical User Interface

在本章中，我们将探讨pdCalc的图形用户界面（GUI）的设计。 每当设计GUI时，都需要选择一个小部件平台。 如前所述，我选择使用Qt来创建GUI。 也就是说，这不是使用Qt设计界面的入门指南。 相反，我假设读者具有Qt的使用知识，并且本章本身专注于GUI的设计方面。 实际上，我将尽可能地使读者参考源代码，以查看小部件实现的详细方面。 关于Qt实现的任何讨论都只是偶然的或值得特别强调的。 如果您对GUI设计没有兴趣，则可以完全跳过本章，而不会造成连续性损失。

## 6.1 需求

在第5章中，我们通过导出CLI和GUI都将使用的界面抽象来开始对命令行界面（CLI）的分析。 显然，我们将在此处重用此接口，因此，我们已经知道我们的整个用户界面必须遵循的抽象界面。 因此，我们通过定义GUI特殊的要求来开始本章。

与CLI一样，我们很快发现第1章中的要求不足以指定图形用户界面。 给定的要求仅是功能性的。 也就是说，我们知道计算器应支持哪些按钮和操作，但对预期的外观一无所知。

在一个商业项目中，（希望）聘请客户，图形艺术家和人机交互专家来协助设计GUI。 对于我们的案例研究，充分说明我们自己的要求就足够了：

1. GUI应该有一个同时显示输入和输出的窗口。 输出是当前堆栈的前六个条目。
2. GUI应具有可单击的按钮，用于输入数字和所有受支持的命令。
3. GUI应具有用于显示错误消息的状态显示区域。

以上要求仍然无法解释计算器的实际外观。 为此，我们需要一张照片。 图6-1显示了运行在我的Linux桌面（使用Qt 5.7.1的Kubuntu 16.10）上的计算器。 将完成的GUI作为设计GUI的原型来展示无疑是“作弊”。 希望这种捷径不会过多地损害案例研究的现实性。 显然，在开发的这个阶段还没有成品。 在生产环境中，可能需要手工绘制模型或使用Microsoft PowerPoint，Adobe Illustrator，Inkscape等程序绘制模型。或者，可能是从一个物理对象对GUI进行建模，而设计师可能有照片。 或直接访问该对象。 例如，可能正在设计用来代替物理控制系统的GUI，并且要求指定界面必须显示相同的刻度盘和仪表（以减少操作员的再培训成本）。

pdCalc的GUI的设计灵感来自我的HP48S计算器。 对于那些熟悉本系列中的任何Hewlett-Packard计算器的人来说，其界面都会有些熟悉。 对于那些不熟悉该系列计算器的人（可能是大多数读者），以下说明介绍了GUI的基本行为。

GUI的顶部三分之一是专用的输入/输出（I / O）窗口。 I / O窗口在左侧显示前六个堆栈级别的标签，而堆栈的顶部在窗口的底部。 堆栈中的值显示在窗口右侧与堆栈中数字位置相对应的行的右侧。 当用户输入一个数字时，堆栈减少为仅显示前五个堆栈元素，而输入的数字则在底行左对齐显示。 按下Enter键终止一个号码并将其输入到堆栈中。

如果有足够的输入，只要按下按钮就立即进行操作。 如果没有足够的输入，则会在I / O窗口上方显示一条错误消息。 对于命令，输入区域中的有效数字被视为堆栈顶端的数字。 也就是说，在输入数字时应用操作等同于按Enter，然后应用操作。

为了节省空间，某些按钮在按钮本身的上方和左侧都有移位的操作。 可以通过以下方式激活这些已转换的操作：首先按下Shift按钮，然后再按下已转换文本下方的按钮。 按下移位按钮会将计算器置于移位模式，直到按下具有移位操作的按钮或再次按下移位按钮为止。 为了清楚起见，移位操作通常与按钮上的操作相反。

为了简化输入，许多按钮都绑定到键盘快捷键。 按下相应的数字键可激活数字，按下Enter键可激活输入按钮，按下s键可激活移位，按下Backspace键可激活退格，按下e键可激活幂运算， 并通过按相应的键激活四个基本算术运算（+，-，*，/）。

最后，一些操作是半隐藏的。 当不输入数字时，退格按钮将从堆栈中删除顶部的条目，而输入按钮则复制堆栈中的顶部条目。 这些组合中的某些组合不直观，因此可能不代表非常好的GUI设计。 但是，它们确实模仿了HP48S上使用的输入。 如果您以前从未使用过HP48系列计算器，我强烈建议您在继续之前先从GitHub存储库构建并熟悉GUI。

如果您想知道proc键是做什么的，它将执行存储过程。 这是我们在第8章中会遇到的“新”要求之一。

对GUI的第一个批评可能是它不是很漂亮。 我同意。 本章中GUI的目的不是演示高级Qt功能。 相反，其目的是说明如何将代码库设计为模块化，健壮，可靠和可扩展的。 添加代码以使GUI更具吸引力而不是功能，这将分散此消息的注意力。 当然，该设计允许使用更漂亮的GUI，因此请在提供的基础架构之上随意制作自己的漂亮GUI。

现在，我们有足够的细节来设计和实现计算器的GUI。 但是，在开始之前，必须对构建GUI的候选方案进行简短的讨论。

## 6.2 构建GUI

本质上，存在两种不同的构建GUI的路径：在集成开发环境（IDE）中构建GUI或在代码中构建GUI。 在这里，无论是使用传统的编程语言（如C ++）还是声明性标记语法（如XML），我都会宽松地使用术语代码来表示通过文本构建GUI。 当然，在两种极端之间是混合方法，它利用了IDE和代码中的元素。

### 6.2.1 使用IDE构建GUI

如果只需要一个简单的GUI，那么在IDE中设计和构建GUI无疑是更简单的方法。 大多数IDE具有图形界面，用于在画布上布置可视元素，例如，它可以表示对话框或小部件。 设置新画布后，用户可以通过将现有窗口小部件拖放到画布上来直观地构建GUI。 现有的窗口小部件由GUI工具包的内置图形元素（例如按钮）以及已在IDE框架中启用拖放功能的自定义窗口小部件组成。 布局完成后，可以通过图形或少量代码将操作绑定在一起。 最终，IDE将创建与图形化GUI相对应的代码，并且此IDE创建的代码将与其余的源代码一起编译。

使用IDE构建GUI具有优点和缺点。 一些优点如下。 首先，由于该过程是直观的，因此您在执行布局时可以轻松看到GUI的外观。 这与编写GUI的代码形成直接对比，在GUI中，您仅在编译和执行代码后才能看到GUI的外观。 区别非常类似于使用Microsoft Word之类的WYSIWYG文本编辑器与诸如LaTeX之类的标记语言来书写纸张之间的区别。 其次，IDE通过在后台自动生成代码来工作，因此，图形化方法可以显着减少编写GUI所需的编码量。 第三，IDE通常会在属性表中列出GUI元素的属性，这使得在不经常查阅API文档的情况下简化GUI的样式变得很简单。 这对于很少使用的功能特别有用。

使用IDE来构建GUI的一些缺点如下。首先，您仅限于IDE选择公开的API子集。有时完整的API是公开的，有时则不是。如果您需要IDE的作者选择不授予您的功能，则将被迫编写自己的代码。也就是说，IDE可能会限制对GUI元素的微调控制。其次，对于重复的GUI元素，您可能必须执行多次相同的操作（例如，单击以使所有按钮中的文本变为红色），而在代码中，可以轻松地将任何重复的任务封装在类或函数调用中。第三，使用IDE设计GUI会将GUI限制为只能在编译时做出的决定。如果您需要动态更改GUI的结构，则需要为此编写代码。第四，在IDE中设计GUI会将您的代码绑定到特定的供应商产品。在公司环境中，这可能不是主要问题，因为整个公司的开发环境可能是统一的。但是，对于一个开放源代码的分布式项目，并不是每个可能希望为您的代码库做出贡献的开发人员都希望被限制为您选择的同一IDE。

### 6.2.2 使用代码构建GUI

用代码构建GUI。与其以图形方式将小部件放置在画布上，不如编写代码以与GUI工具箱进行交互。对于如何编写代码，存在多个不同的选项，并且对于任何给定的GUI工具包，通常有多个选项可供您使用。首先，您几乎总是可以用工具箱的语言编写源代码。例如，在Qt中，您可以通过以非常必要的方式编写C ++来完全构建GUI（即，您明确指示GUI的行为）。其次，某些GUI工具箱允许使用声明式样式（即，您编写描述GUI元素样式的标记代码，但该工具箱定义了元素的行为）。最后，某些工具包可能使用基于脚本的界面来构造GUI（通常是JavaScript或JavaScript派生语法），同时可能还使用声明性标记。在本章的上下文中，以代码构建GUI完全是指针对Qt的桌面小部件集使用C ++进行编码。

如您所料，用代码构建GUI与使用IDE构建GUI具有几乎相反的利弊。 优点如下。 首先，完全公开了小部件的完整API。 因此，程序员可以根据需要进行微调。 如果小部件库设计者希望用户能够执行某项操作，则可以通过代码来完成。 其次，通过使用抽象，可以轻松地管理重复的GUI元素。 例如，在设计计算器时，我们不必手动自定义每个按钮，而是可以创建一个按钮类并简单地实例化它。 第三，在运行时动态添加小部件很容易。 对于pdCalc，此优势对于满足支持动态插件的要求非常重要。 第四，如果构建系统独立于IDE，则在代码中设计GUI可以授予IDE完全的独立性。

尽管在代码中构建GUI具有许多优点，但也存在缺点。首先，布局不可见。为了看到GUI成形，您必须编译并执行代码。如果看起来不对，则必须调整代码，再试一次，然后重复此过程，直到正确为止。这可能非常繁琐且耗时。其次，您必须自己编写所有代码。 IDE将自动生成很大一部分GUI代码，尤其是与布局相关的部分，而在编写代码时，则必须手动完成所有工作。最后，在用代码编写GUI时，您将无法在属性表上简洁地访问小部件的所有属性。通常，您需要更频繁地查阅文档。也就是说，良好的IDE代码完成可以大大帮助完成此任务。有人可能对我的最后一句话感到粗鲁，声称：“表明使用IDE可以减轻不使用IDE的弊端是不公平的。”请记住，除非您在纯文本编辑器中编写源代码（不太可能），否则代码编辑器仍可能是复杂的IDE。我的比较是在使用IDE的图形GUI布局工具构建GUI与使用现代代码编辑器（可能本身就是IDE）手动编写代码之间。

### 6.2.3 哪种构建方式更好？

当然，对于节标题中过于笼统的问题，答案都不是。 哪种技术更适合构建GUI，这完全取决于上下文。 当您在自己的编码追求中遇到此问题时，请参考上述折衷方法，并根据您的情况选择最明智的选择。 通常，最好的解决方案是一种混合策略，其中GUI的某些部分将以图形方式进行布局，而GUI的其他部分将完全由代码构建。

在我们的上下文中，一个更具体的问题是：“哪种GUI构建方法更适合pdCalc？” 对于此应用程序，需要在权衡中优先考虑基于代码的方法。 首先，计算器的视觉布局相当琐碎（状态窗口，显示小部件和
按钮网格），并且很容易用代码完成。 这一事实立即消除了IDE方法的最大优势：可视化地处理复杂的布局。 其次，按钮的创建和布局是重复的，但易于封装，这是基于代码的方法的优点之一。 最后，由于计算器必须支持运行时插件，因此代码方法可更好地动态添加小部件元素（运行时发现的按钮）。

在本章的其余部分，我们将在代码中探索pdCalc GUI的设计。 特别是，主要重点将放在组件及其接口的设计上。 因为我们的重点不在小部件构造上，所以将掩盖许多实现细节。 但是不要害怕。 如果您对这些细节感兴趣，可以在GitHub存储库中阅读所有代码。

## 6.3 Modularization

从本书的开头，我们讨论了计算器的分解策略。 使用MVC架构模式，我们将设计分为模型，视图和控制器。 在第4章中，我们看到了主要的组件之一（命令分派器）被分成了子组件。 CLI非常简单，不需要模块化，而GUI非常复杂，因此分解很有用。

在第5章中，我们确定了系统的任何用户界面都必须继承UserInterface抽象类。 本质上，UserInterface类以MVC模式定义视图的抽象接口。 虽然GUI模块必须继承自UserInterface，并因此向控制器提供相同的抽象接口，但是我们可以自由地分解GUI的内部结构。 我们将再次使用松散耦合和强大内聚力的指导原则对GUI进行模块化。

分解模块时，首先要考虑强大的凝聚力。也就是说，我试图将模块分解为每个小组件，每个小组件都做一件事情（并且做得很好）。让我们通过GUI进行尝试。首先，任何Qt GUI必须具有通过继承QMainWindow定义的主窗口。主窗口也是MVC视图的入口点，因此我们的主窗口也必须继承自UserInterface。 MainWindow是我们的第一个类。接下来，目视检查图6-1，显然将计算器分为用于输入（按钮集合）的组件和用于显示的组件。因此，我们再添加两个类，InputWidget和Display。我们已经讨论过，使用代码方法构建GUI的一个好处是抽象出重复创建的按钮，因此我们还将创建一个CommandButton类。最后，我们添加一个组件来管理计算器的外观（例如，字体，边距，间距等），该组件被恰当地命名为LookAndFeel类。还存在用于存储过程输入的组件，但是我们将对该组件的讨论推迟到第8章。

现在，从CommandButton开始研究每个类的设计。 如果需要优化，我们将随时开始讨论任何对该初始分解的必要改进。

### 6.3.1 CommandButton的抽象

我从按钮如何抽象开始讨论。 这是一个明智的起点，因为按钮是计算器数字和命令输入机制的基础。

Qt提供了一个按钮小部件类，该类显示可单击的按钮，单击该按钮时会发出信号。 这个QPushButton类为我们进行数字和命令输入提供了所需的基本功能。 我们可以采用的一种预期设计是按原样使用QPushButtons。 这种设计将需要显式地编写代码，以将每个QPushButton手动连接到其自己的自定义插槽。 但是，这种方法是重复的，乏味的，并且容易出错。 此外，某些按钮需要QPushButton API未提供的其他功能（例如，移位输入）。 因此，我们改为在QPushButton的基础上为我们的程序寻求按钮抽象，用其他功能补充该Qt类，同时限制QPushButton的界面来完全满足我们的要求。 我们将此类称为CommandButton。

用模式的话来说，我们提出了既充当适配器又充当外观的东西。 我们在第三章中看到了适配器模式。外观模式是近亲。 适配器模式负责将一个接口转换为另一种接口（可能需要进行一些修改），而外观模式则负责为子系统中的一组接口提供统一的接口（通常是为了简化）。 我们的CommandButton承担了两者的任务。 我们都在将QPushButton接口简化为pdCalc需要的受限子集，但同时又调整了QPushButton的功能来满足我们问题的要求。 那么，CommandButton是外观还是适配器？ 区别在于语义； 它具有每个特征。 请记住，了解不同模式的目标并根据您的需求进行调整非常重要。 尽量不要为了模式纯净而在“四人帮” [6]的死记硬背实现中迷路。

### 6.3.2 CommandButton的设计

除了介绍性的说明外，我们仍然必须确定CommandButton到底需要做什么以及如何与GUI的其余部分进行交互。 在许多方面，CommandButton的外观和行为与QPushButton相似。 例如，一个CommandButton必须提供一个可以单击的可视按钮，并且在单击该按钮之后，它应该发出某种信号以让其他GUI组件知道发生了单击动作。 但是，与标准QPushButton不同，我们的CommandButton必须同时支持标准状态和转换状态（例如，同时支持sin和arcsin的按钮）。 这种支持应该是可视的（两种状态都应通过CommandButton小部件显示）和功能性的（单击信号必须描述标准单击和平移单击）。因此，我们有两个设计问题要回答。 首先，我们如何设计和实现窗口小部件以使其正确显示在屏幕上？ 其次，一般而言，计算器将如何处理移位操作？

我们首先来解决CommandButton的外观问题。 当然，我们可以从头开始实现按钮，手动绘制屏幕，并使用鼠标事件来捕获按钮单击，但这对CommandButton来说是过大的了。 相反，我们寻求一种可以重用Qt的QPushButton类的解决方案。 本质上，我们有两个重用选项：继承和封装。

首先，让我们考虑通过继承在CommandButton类的设计中重用QPushButton类。这种方法是合理的，因为可以从逻辑上采用CommandButton是“是一个” QPushButton的观点。然而，这种方法存在直接的缺陷。 “是一个”关系意味着公共继承，这意味着QPushButton的整个公共接口将成为CommandButton的公共接口的一部分。但是，我们已经确定，为了简化pdCalc中的操作，我们希望CommandButton具有受限制的接口（外观模式）。 OK，让我们尝试私有继承，并将我们的观点修改为CommandButton和QPushButton之间的“ implements-a”关系。现在我们遇到第二个缺陷。没有从QPushButton的公共继承，CommandButton将失去对QWidget类的间接继承，而QWidget类是Qt在类中成为用户界面对象的先决条件。因此，任何私有继承QPushButton的实现都将需要从QWidget公开继承。但是，由于QPushButton也继承自QWidget，因此CommandButton对这两个类的多重继承将导致歧义，因此被禁止。我们必须寻求替代设计。

现在，考虑将QPushButton封装在CommandButton中（即CommandButton“ has-a” QPushButton）。我们可能应该从这个选项开始，因为一般实践表明，在可能的情况下，我们应该首选封装而不是继承。但是，许多开发人员倾向于从继承开始，我想讨论这种方法的弊端，而不仅仅依靠C ++规范。除了打破强大的继承关系之外，选择封装方法还可以克服使用继承问题的两个缺点。首先，由于QPushButton将封装在CommandButton中，因此我们可以自由地公开仅QPushButton接口的那些对我们的应用有意义的部分。其次，通过使用封装，我们将避免同时继承QWidget和QPushButton类的多重继承混乱。请注意，我原则上不反对使用多重继承的设计。在这种情况下，多重继承就是模棱两可的。

封装关系可以采用组合或聚合的形式。 哪个适合CommandButton类？ 考虑两个类，A和B，其中A封装B。在组合关系中，B是A的组成部分。在代码中，该关系表示如下：

```c++
class A
{
    // ...
private:
    B b_;
};
```

相反，聚合意味着A仅在内部使用B对象。 在代码中，聚合表示如下：

```c++
class A
{
    // ...
private:
    B* b_; // or some suitable smart pointer or reference
};
```

对于我们的应用程序，我认为聚合更有意义。 也就是说，我们的CommandButton使用QPushButton而不是由QPushButton组成。 区别是微妙的，并且可以采用同样逻辑的论点来声明关系是复合的。 也就是说，这两种设计都可以在Qt内机械地工作，因此您的编译器实际上并不关心您如何选择表达关系。

现在，我们决定在CommandButton中聚合QPushButton，我们可以继续进行CommandButton类的总体设计。我们的CommandButton必须同时支持主要和辅助命令。在视觉上，我选择将主要命令显示在按钮上，并将次要命令显示为按钮上方和左侧的蓝色。 （我将讨论转换后的状态是如何瞬间操作的。）因此，CommandButton只是实例化了QPushButton和QLabel并将它们都放置在QVBoxLayout中。 QPushButton显示主要命令的文本，而QLabel显示移位命令的文本。布局如图6-2所示。如前所述，为了完成设计，以图形方式与GUI的其余部分进行交互，CommandButton必须公开地继承自QWdiget类。该设计将为通用按钮生成一个可重用的CommandButton小部件类，同时声明一个主命令和一个辅助命令。因为按钮操作是通过使用QPushButton来实现的，所以CommandButton类的总体实现非常简单。

关于重用QPushButton的最后一个小细节仍然存在。 显然，由于QPushButton私下封装在CommandButton中，因此客户端无法从外部连接到QPushButton的clicked（）信号，这使得客户端代码无法知道何时单击CommandButton。 这种设计实际上是故意的。 CommandButton会在内部捕获QPushButton的clicked（）信号，然后重新发射其自己的信号。 此公共CommandButton信号的设计与转换状态的处理紧密联系在一起。

现在，我们回到对计算器内的移位状态建模的过程。 我们有两个实用的选择。 第一种选择是让CommandButton理解计算器何时处于移位状态，并且仅发出正确的移位或未移位命令信号。 另外，第二种选择是使CommandButton信号具有已移位和未移位的命令，并让信号的接收者分拣计算器的当前状态。 让我们研究两个选项。

第一个选项很容易实现，让CommandButton知道计算器是处于移位状态还是未移位状态。 在一种实现方式中，当按下切换按钮时，它会通过Qt信号和插槽通知每个按钮，并且这些按钮在切换状态和未切换状态之间切换。 如果需要的话，每当切换切换状态时，甚至可以将切换位置的文本与按钮上的文本交换。 或者，可以将换档按钮连接到一个插槽，该插槽设置一个全局换档状态标志，当按钮发出信号发生单击时，可以查询这些标志。 在这两种实现方案中，单击按钮时，仅会发出当前状态的命令，并且此命令的接收者最终会通过commandEntered（）事件将单个命令从GUI转发出去。

在第二个选项中，不需要CommandButton知道有关计算器状态的任何信息。 相反，当单击按钮时，它会发出处于已移位和未移位状态的信号。 本质上，按钮仅在单击时通知其侦听器，并提供两种可能的命令。 然后，接收方负责确定在commandEntered（）事件中引发哪些可能的命令。 大概接收者必须负责跟踪转换后的状态（或者能够轮询另一个持有该状态的类或变量）。

对于CommandButton，两种用于处理计算器状态的设计都可以很好地工作。但是，就我个人而言，我更喜欢不需要CommandButton知道任何有关转换状态的设计。我认为，这种设计可促进更好的内聚力和更宽松的耦合。该设计更具凝聚力，因为CommandButton应负责显示可单击的小部件并在单击按钮时通知系统。要求CommandButton理解计算器状态会侵犯其抽象的独立性。这些按钮不仅是带有两个命令的通用可单击按钮，而且还与计算器的全局状态概念紧密联系在一起。此外，通过强制CommandButton理解计算器的状态，通过强制将CommandButton不必要地与Shift按钮或必须轮询的类互连，可以增加系统中的耦合。通过在按下Shift键时通知每个CommandButton唯一的好处是能够将标签交换为主命令和辅助命令。当然，标签交换可以独立于CommandButton的信号参数来实现。

### 6.3.3 CommandButton的接口

正确设计是最困难的部分。 有了手头的设计，该界面几乎可以自行编写。 让我们研究一下CommandButton类定义的简化版本，如清单6-1所示。

```c++
class CommandButton : public QWidget
{
    Q_OBJECT // needed by all Qt objects with signals and slots
public:
    CommandButton(const string& dispPrimaryCmd, const string& primaryCmd,
                  const string& dispShftCmd, const string& shftCmd,
                  QWidget* parent = nullptr);
    CommandButton(const string& dispPrimaryCmd, const string& primaryCmd,
                  QWidget* parent = nullptr);
private slots:
    void onClicked();
signals:
    void clicked(string primCmd, string shftCmd);
};
```

CommandButton类具有两个构造函数：四参数重载和二参数重载。 四参数重载允许指定主要命令和辅助命令，而二参数重载允许仅指定主要命令。 每个命令需要两个字符串才能完整说明。 第一个字符串等于标签将出现在GUI上的文本，无论是在按钮上还是在已转换的命令位置。 第二个字符串等效于commandEntered（）事件引发的文本命令。 可以通过要求这两个字符串相同来简化接口。 但是，我选择增加显示与命令分派器所需文本不同的灵活性。 注意，由于尾随父指针，我们需要重载而不是默认参数。

界面的唯一其他公共部分是clicked（）信号，该信号与按钮的主要命令和移位命令一起发出。 前面已经讨论了二参数与一参数信号背后的原理。 尽管是私有的，但我还在CommandButton的界面中列出了onClicked（）插槽，以突出显示必须创建的私有插槽，以捕获内部QPushButton的clicked（）信号。 onClicked（）函数的唯一目的是捕获QPushButton的clicked（）信号，而使用两个函数参数发出CommandButton的clicked（）信号。

如果您在CommandButton.h中查看CommandButton类的实际声明，您将在CommandButton的公共接口中看到一些其他功能。 这些只是转发功能，它们可以更改外观（例如，文本颜色）或将可视元素（例如，工具提示）添加到基础QPushButton。 虽然这些功能是CommandButton界面的一部分，但它们在功能上是可选的，并且独立于CommandButton的基础设计。

### 6.3.4 Getting Input

GUI需要从用户那里接受两种不同类型的输入：数字和命令。 用户通过网格中排列的命令按钮（或映射到这些按钮的键盘快捷键）输入两种输入类型。 CommandButton的集合，它们的布局以及与GUI其余部分的关联信号组成了InputWidget类。

命令输入在概念上很简单。 单击一个CommandButton，并发出一个信号，以反映该特定按钮的命令。 最终，GUI的另一部分将接收到此信号并引发commandEntered（）事件，以由命令调度程序处理。

输入数字比输入命令要复杂一些。 在CLI中，我们可以简单地允许用户键入数字并在输入完成后按Enter。 但是，在GUI中，我们没有这样的内置机制（假设我们希望GUI比Qt窗口中的CLI更复杂）。 尽管计算器具有用于输入数字的命令，但请记住，它假定使用完整的数字，而不是单个数字。 因此，GUI必须具有构造数字的机制。

建立数字包括输入数字和特殊符号，例如小数点，加/减运算符或乘幂运算符。 此外，随着用户的输入，他可能会出错，因此我们也要启用基本的编辑功能（例如，退格键）。 数字的组装是一个两步过程。 InputWidget仅负责发出组成和编辑数字所需的按钮单击。 GUI的另一部分将接收这些信号并组装完整的数字输入。

### 6.3.5 The Design of the InputWidget

从概念上讲，InputWidget类的设计很简单。 小部件必须显示生成和编辑输入所需的按钮，将这些按钮绑定到键（如果需要），并在单击这些按钮时发出信号。 如前所述，InputWidget包含用于数字输入和命令输入的按钮。 因此，它负责数字0-9，加/减按钮，十进制按钮，乘幂按钮，回车按钮，退格按钮，移位按钮以及每个命令的按钮。 回想一下，作为一种节省，CommandButton类允许每个可视按钮使用两个不同的命令。

为了使整个GUI保持一致，我们将专门使用CommandButton来表示所有输入按钮，即使是既不发出命令也不进行二次操作的按钮（例如0按钮）。 我们的CommandButton设计如此灵活多么方便！ 但是，该决定仍然给我们带来两个突出的设计问题。 我们如何在视觉上布置按钮？单击按钮时该怎么办？

存在两个用于在InputWidget中放置按钮的选项。 首先，InputWidget本身拥有一个布局，它将所有按钮放置在此内部布局中，然后InputWidget本身可以放置在主窗口中的某个位置。 另一种选择是让InputWidget在构造过程中接受外部拥有的布局，并将其CommandButtons放置在该布局上。 通常，让InputWidget拥有自己的布局是上乘的设计。 与替代方法相比，它具有更高的凝聚力并减少了耦合。 首选让InputWidget接受外部布局的唯一例外是，如果设计要求其他类共享相同的布局以放置其他窗口小部件，则它是首选。 在这种特殊情况下，使用两个类外部拥有的共享布局会更干净。

现在，我们将注意力转向在InputWidget中单击按钮时发生的情况。 因为InputWidget封装了CommandButtons，所以InputWidget类的使用者不能直接访问每个CommandButton的clicked（）信号。 因此，InputWidget必须捕获其所有CommandButton的单击并重新发送它们。 对于正弦或切线之类的计算器命令，重新发出咔嗒声是微不足道的转发命令。 实际上，Qt启用了一种简写形式，用于将CommandButton的clicked（）信号直接连接到InputWidget commandEntered（）信号，从而无需通过InputWidget中的专用插槽。 通过从InputWidget的专用插槽中捕获来自CommandButton的特定clicked（）信号并随后发出InputWidget，可以更好地处理数字，数字编辑按钮（例如，加/减，退格键）和计算器状态按钮（例如，移位）。 这些动作的信号。

如前所述，在按下每个输入按钮时，InputWidget必须发出自己的信号。 在一个极端情况下，每个内部CommandButton的InputWidget可能具有单独的信号。 在另一个极端，不管按下按钮如何，InputWidget都只能发出一个信号，并通过参数来区分动作。 不出所料，对于我们的设计，我们将寻求一些折中方案，以共享每个极端的要素。

本质上，InputWidget接受三种不同的输入类型：修饰符（例如，enter，backspace，加/减，shift），科学计数法字符（例如，0-9，十进制，幂运算）或命令（例如，正弦） ，余弦等）。 每个修饰符都需要一个唯一的响应。 因此，每个修饰符都绑定到自己的单独信号。 另一方面，可以通过在屏幕上显示输入字符（Display类的作用）来简单地统一处理科学记号字符。 因此，科学记号字符都是通过发出将特定字符编码为自变量的单个信号来处理的。 最后，通过发出单个信号来处理命令，该信号简单地将主命令和辅助命令逐字转发为信号的函数参数。

在构造信号处理时，重要的是将InputWidget维护为一个类，以将原始用户输入信号发送到GUI的其余部分。 让InputWidget解释按钮按下会导致问题。 例如，假设我们将InputWidget设计为聚集字符，并且仅发出完整的有效数字。 由于此策略意味着每个字符输入都不会发出信号，因此在完成编号之前无法显示或编辑字符。 这种情况显然是不可接受的，因为用户肯定希望在输入字符时在屏幕上看到每个字符。

现在，我们将注意力转移到将设计转换为InputWidget的最小接口上。

### 6.3.5 The Interface of the InputWidget

让我们通过提供类声明开始对InputWidget界面的讨论。 不出所料，我们清晰的设计带来了直观的界面。 参见清单6-2。

```c++
class InputWidget : public QWidget
{
    Q_OBJECT
public:
    explicit InputWidget(QWidget* parent = nullptr);
signals:
    void characterEntered(char c);
    void enterPressed();
    void backspacePressed();
    void plusMinusPressed();
    void shiftPressed();
    void commandEntered(string, string);
};
```

本质上，整个类接口由对应于用户输入事件的信号定义。 具体来说，我们有一个信号指示任何科学符号的输入，一个信号指示命令按钮的单击，而单独的信号分别指示单击退格键，Enter键，加号或减号或Shift键。

如果您在InputWidget.cpp文件中查看GitHub存储库源代码，则会发现一些其他公共功能和信号。 这些额外的功能对于实现后续章节中介绍的两个功能是必需的。 首先，需要addCommandButton（）函数和setupFinalButtons（）函数来适应插件按钮的动态添加，这是第7章中介绍的功能。其次，需要procedurePressed（）信号指示用户请求使用存储过程。 存储过程在第8章中介绍。

## 6.4 The Display

从概念上讲，计算器有两个显示，一个用于输入，一个用于输出。 这种抽象可以在视觉上实现为两个单独的显示或一个合并的输入/输出显示。 两种设计都是完全有效的。 每个都如图6-3所示。

选择一种I / O风格与另一种I / O风格最终会降低客户的偏好。 由于对这两种样式都没有特别的亲和力，因此我选择了一个合并的显示器，因为它看起来更像我的HP48S计算器的显示器。 选择了一种展示样式后，现在让我们集中讨论此选择所隐含的设计含义。

如图6-3a所示，通过一个用于输入和输出的单独的屏幕小部件，选择具有单独的输入和输出显示类的选择将是显而易见的。 输入显示器将具有用于接收InputWidget信号的插槽，输出显示器将具有用于接收完整的编号（来自输入显示器）和堆栈更新的插槽。 内聚力很强，组件的分离是适当的。

但是，我们的设计需要混合的输入/输出显示，如图6-3b所示。混合设计极大地改变了使用独立的输入和输出显示类别的敏感性。虽然将输入和输出显示关注点集中到一个类中确实会降低显示的凝聚力，但是尝试维护两个独立的类，它们都指向同一个屏幕小部件，将导致尴尬的实现。例如，选择哪个类应拥有底层Qt小部件是任意的，可能会导致共享小部件设计（也许使用shared_ptr？）。但是，在这种情况下，输入显示类或输出显示类是否应该初始化屏幕小部件？如果输入显示共享指向单个显示小部件的指针，那么输入显示向输出显示发信号是否有意义？答案很简单，即使我们可能更愿意将输入和输出显示问题分开，但对于合并的I / O显示小部件，两类设计是站不住脚的。

前面的讨论确定了一些有趣的观点。 首先，在屏幕上直观显示设计可以合理地更改底层组件的设计和实现。 尽管一旦提供了具体的GUI示例似乎就显而易见了，但间接的含义是，如果仅对屏幕小部件进行一些更改，则可能需要对GUI类的设计进行重大更改。 其次，当设计直接与第2章中假定的良好设计的要素相矛盾时，存在结果更干净的情况。显然，第2章中的准则旨在帮助设计过程，而不是成为不可侵犯的规则。 就是说，我的一般建议是旨在保持对遵循准则的清晰性，但只能明智地违反最佳做法。

既然我们已经决定追求具有单个基础Display类的单个I / O显示器，那么让我们来看一下它的设计。

### 6.4.1 The Design of the Display class

我承认。 我对Display类的原始设计和实现是不好的。 我没有使用适当的分析技术和前期设计，而是边实现边设计。 但是，一旦我的设计迫使Display类发出commandEntered（）信号以使GUI正常运行，我就知道此设计有“坏味道”。 负责在屏幕上绘制数字的类可能不应该解释命令。 就是说，该实现工作正常，所以我保留了代码，并完成了计算器。 但是，当我最终开始撰写有关设计的文章时，我很难为设计提出合理的理由，以至于我最终不得不承认，设计存在致命缺陷，迫切需要重写。

显然，在重新设计了显示器之后，我本可以选择仅描述改进的产品。 但是，我认为研究我的第一个误导性尝试，讨论该设计存在一些严重问题的迹象，以及最终查看经过一整夜重构的最终设计是有启发性的。 可能，这里最有趣的一课是不良的设计肯定会导致正常工作的代码，因此永远不要认为正常工作的代码是良好设计的指标。 此外，不良设计如果可以本地化，则可以进行重构，有时仅应进行重构以提高清晰度。 当然，重构假设您的项目进度表包含足够的应急时间，可以定期暂停以偿还技术债务。 在返回到更好的设计之前，让我们简要地研究一下我的错误。

### 6.4.2 垃圾设计

根据上面的分析，我们确定计算器应该具有一个统一的Display类来处理输入和输出。 在我的显示器设计中，根本的错误是由于错误地认为一个Display类不暗示其他有关正交关注的类而导致的。 因此，我开始将InputWidget类未处理的所有功能集中到一个Display类中。 让我们从那条道路开始。 但是，我们不会像以前那样完成设计和实现，而是在看到第一个致命缺陷（我本来应该做的）后立即停止并重新设计该类。

通过单一的Display类设计，Display负责显示来自用户的输入和来自计算引擎的输出。显示输出是微不足道的。 Display类会观察stackChanged（）事件（由于它不是GUI外部接口的一部分，因此是间接的），并使用新的堆栈值更新屏幕显示小部件（在这种情况下为QLabel）。从概念上讲，显示输入也是微不足道的。显示器直接接收InputWidget类发出的信号（例如characterEntered（）），并使用当前输入更新屏幕显示控件。这种交互的简单性掩盖了该设计的基本问题，即该输入不是原子输入的，以用于显示。相反，它是通过独立输入几个字符并按回车按钮完成输入而组装在多个信号上的。输入的这种顺序构造意味着计算器必须保持活动的输入状态，并且输入状态在显示小部件中不存在任何业务。

那么，除了思想上的厌恶之外，Display类保持输入状态又有什么问题呢？我们不能仅将状态视为显示输入缓冲区吗？让我们继续进行此设计，看看它为什么有缺陷。例如，考虑退格按钮，其操作根据输入状态而过载。如果当前输入缓冲区是非空的，则退格按钮将从该缓冲区中删除一个字符。但是，如果当前输入缓冲区为空，则按Backspace键会导致发出该命令以从堆栈中删除最高编号。因为在这种设计下
拥有输入状态，并且是backspacePressed（）信号的接收器，因此Display必须是stack命令中删除的数字的来源。在Display开始发布命令后，我们已经完全放弃了凝聚力，现在是时候来寻找意大利面酱了，因为随后会出现意大利面代码。从这里开始，我不仅放弃了设计，还加倍努力，实际上我的原始设计变得更糟。不过，让我们继续研究一种更好的方法，而不是继续沿着这种错误的道路前进。

### 6.4.3 好的显示设计

在讨论较差的显示设计的早期，我指出了致命的错误来自于假设统一的显示需要单一类的设计。 但是，正如我们所看到的，该假设是无效的。 计算器中状态的出现意味着至少需要两类，一类用于视觉显示，一类用于状态。

这是否使您想起了我们已经看到的模式？ GUI需要维护内部状态（模型）。 我们目前正在设计显示器（视图）。 我们已经设计了一个类InputWidget，用于接受输入和发出命令（控制器）。 显然，GUI本身不过是一个熟悉的模式的模型视图控制器（MVC）的实施例。 请注意，相对于第2章图2-2中看到的MVC原型，GUI可以用间接通信代替控制器和模型之间的直接通信。 Qt的信号和时隙机制促进了这种微小的变化，从而促进了耦合的减少。

现在，我们将注意力转移到新引入的模型类的设计上。 模型完成后，我们将返回Display类以完成其现在更简单的设计和界面。

### 6.5 The Model

我恰当地称为GuiModel的模型类负责GUI的状态。 为了正确地实现此目标，模型必须是导致系统状态改变的所有信号的接收器，并且它必须是指示系统状态已改变的所有信号的源。 自然地，模型也是系统状态的存储库，它应该为GUI的其他组件提供查询模型状态的工具。 让我们看一下清单6-3中的GuiModel接口。

```c++
class GuiModel : public QObject
{
    Q_OBJECT
public:
    enum class ShiftState { Unshifted, Shifted };
    struct State { /* discussed below */ };
    GuiModel(QObject* parent = nullptr);
    ~GuiModel();
    void stackChanged(const vector<double>& v);
    const State& getState() const;
public slots:
    // called to toggle the calculator's shift state
    void onShift();
    // paired to InputWidget's signals
    void onCharacterEntered(char c);
    void onEnter();
    void onBackspace();
    void onPlusMinus();
    void onCommandEntered(string primaryCmd, string secondaryCmd);
signals:
    void modelChanged();
    void commandEntered(string s);
    void errorDetected(string s);
};
```

GuiModel类中的六个插槽均对应于InputWidget类发出的信号。 GuiModel解释这些请求，适当地更改内部状态，并发出其自己的一个或多个信号。 特别值得注意的是commandEntered（）信号。 GuiModel的onCommandEntered（）插槽接受两个参数，即与按下的CommandButton对应的原始主要和辅助命令，而GuiModel负责解释GUI的移位状态，并且仅在激活时重新发出commandEntered（）信号命令。

GuiModel界面的其余部分涉及GUI的状态。 我们首先讨论嵌套的国家结构背后的基本原理。 我发现不是将模型状态的每个部分声明为GuiModel中的单独成员，而是将所有状态参数集中到一个结构中，这更加干净。 这种设计允许通过使用一个函数调用的const引用返回整个系统状态，从而简化了模型状态的查询，而不是要求零散地访问各个状态成员。 我选择嵌套State结构，因为它是GuiModel的固有部分，没有独立的用途。 因此，State结构自然属于GuiModel的范围，但必须公开声明其声明，以便GUI的其他组件能够查询该状态。

State结构的组成部分定义了GUI的整个状态。 特别是，此State结构包含一个数据结构，该数据结构保存堆栈上最大可见数的副本，当前输入缓冲区，定义系统移位状态的枚举和定义输入缓冲区有效性的Qt枚举 。 声明如清单6-4所示。

```c++
struct State
{
    vector<double> curStack;
    string curInput;
    ShiftState shiftState;
    QValidator::State curInputValidity;
};
```

一个有趣的问题是，为什么GuiModel的状态会从堆栈顶部缓冲可见的数字？ 假设Stack类是单例，则Display可以直接访问Stack。 但是，显示器仅观察GuiModel中的更改（通过modelChanged（）插槽）。 由于与堆栈更改无关的状态更改在GUI中经常发生（例如，字符输入），因此由于每个DisplayChanged（）事件都不是直接观察者，因此Display不得不在每个modelChanged（）事件上浪费时间地查询Stack。 另一方面，GuiModel是stackChanged（）事件的观察者（间接通过MainWindow的函数调用）。 因此，有效的解决方案是让GuiModel仅在计算器的堆栈实际更改时才更新堆栈缓冲区，并授予Display类对此缓冲区的访问权限（通过构造保证是当前的）来更新屏幕。

### 6.6 The Display Redux

现在，我们准备将注意力返回到Display类。 将所有状态和状态交互都放置在GuiModel类中之后，可以将Display类简化为一个对象，该对象监视模型更改并在屏幕上显示计算器的当前状态。 除构造函数外，Display类的接口仅包含两个函数：在模型更改时要调用的插槽，以及在状态区域中显示消息时要调用的成员函数。 后一个函数调用用于显示在GUI中检测到的错误（例如，无效输入）以及在命令分配器中检测到的错误（通过UserInterface的postMessage（）传输）。 清单6-5给出了Display类的整个接口。

```c++
class Display : public QWidget
{
    Q_OBJECT
public:
    explicit Display(const GuiModel& g, QWidget* parent = nullptr,
                     int nLinesStack = 6, int minCharWide = 25);
    void showMessage(const string& m);
public slots:
    void onModelChanged();
};
```

Display类的构造函数的可选参数仅指示屏幕上堆栈的视觉外观。 具体地说，Display类的客户端在要显示的堆栈行数和屏幕显示的最小宽度（以固定宽度的字体字符为单位）方面具有灵活性。

### 6.7 Trying It Together: The Main Window

主窗口是一个很小的类，有很大的用途。确切地说，它在我们的应用程序中具有三个目的。首先，与大多数基于Qt的GUI一样，我们需要提供一个从QMainWindow公开继承的类，该类自然充当应用程序的主GUI窗口。特别是，这是在启动GUI的函数中实例化并显示的类。按照我典型的创意命名风格，我将该类称为MainWindow。其次，MainWindow用作计算器的视图模块的接口类。也就是说，MainWindow也必须从我们的抽象UserInterface类公开继承。最后，MainWindow类拥有前面讨论的所有GUI组件，并根据需要将这些组件粘合在一起。出于所有实际目的，将组件粘合在一起仅需要将信号连接到其相应的插槽。这些简单的实现细节可以在MainWindow.cpp源代码文件中找到。我们将在本节的其余部分中讨论MainWindow的设计和界面。

我们已经编写了一个Qt应用程序； 很明显，我们将在某个地方有QMainWindow的后代。 就其本身而言，这并不十分有趣。 但是，有趣的是，决定使用多重继承来使同一类也充当其余pdCalc的UserInterface。 就是说，这确实是一个有趣的决定，还是因为某些开发人员对多重继承有道德上的厌恶而显得有些挑衅？

确实，我可以将QMainWindow和UserInterface分为两个单独的类。 在主窗口由菜单，工具栏和多个基础小部件装饰的GUI中，我可能会将两者分开。 但是，在我们的GUI中，QMainWindow库除了为我们的Qt应用程序提供入口点外没有其他用途。 实际上，MainWindow在其QMainWindow角色中没有执行任何其他操作。 因此，创建一个单独的MainWindow类的唯一目的是包含UserInterface类的具体特化，除了避免多重继承外，它没有其他目的。 尽管有些人可能会不同意，但我认为在这种情况下缺少多重继承实际上会使设计复杂化。

上述情况实际上是多重继承是一个绝佳选择的典型示例。 特别是，多重继承在派生类中表现出色，派生类的多个基类具有正交功能。 在我们的例子中，一个基类充当Qt的GUI入口点，而另一个基类充当pdCalc的GUI视图的UserInterface专业化。 注意，这两个基类都不共享功能，状态，方法或祖先。 在至少一个基类是纯抽象（无状态且只有纯虚函数的类）的情况下，多重继承尤其明智。 使用纯抽象基础的多重继承的场景是如此有用，以至于在不允许多重继承的编程语言（例如C＃和Java中的接口）中被允许。

MainWindow的接口仅包含一个构造函数，UserInterface类中两个纯虚函数的替代以及一些用于动态添加命令的函数（设计插件时，您将在第7章中遇到这些函数）。 为了完整起见，清单6-6中显示了MainWindow的接口。

```c++
class MainWindow : public QMainWindow, public UserInterface
{
    class MainWindowImpl;
public:
    MainWindow(int argc, char* argv[], QWidget* parent = nullptr);
    void postMessage(const string& m) override;
    void stackChanged() override;
    // plugin functions ...
};
```



### 6.8 Look-and-Feel

在本章以一些示例代码执行GUI结束之前，我们必须简短地返回到GUI的最终组件LookAndFeel类。 LookAndFeel类仅管理GUI的动态可自定义外观，例如字体大小和文本颜色。 界面很简单。 对于自定义的每个点，都存在一个函数来返回请求的设置。 例如，要获取显示字体，我们提供以下功能：

```c++
class LookAndFeel
{
public:
    // one function per customizable setting, e.g.,
    const QFont& getDisplayFont() const;
    // ...
};
```

因为我们在计算器中只需要一个LookAndFeel对象，所以该类被实现为单例。

有一个很好的问题要问：“为什么我们根本需要这个课程？”答案是，它使我们有机会根据当前环境动态修改计算器的外观，并且将对pdCalc外观的访问集中在内存中。例如，假设我们想让GUI DPI知道并相应地选择字体大小（我不在源代码中，但您可能想要）。使用静态配置文件（或概念上等效的注册表设置），我们将必须在安装过程中为每个平台自定义设置。我们要么必须在安装程序中为每个平台构建自定义，要么我们必须编写代码以在安装期间执行以动态创建适当的静态配置文件。如果我们必须编写代码，为什么不将其放在其所属的源代码中呢？作为实现的决定，可以将LookAndFeel类设计为仅读取配置文件并将外观属性缓冲在内存（外观代理对象）中。这就是LookAndFeel类的真正力量。它集中外观属性的位置，以便只需要更改一个类即可实现全局外观更改。甚至更重要的是，LookAndFeel类将各个GUI组件与实现细节隔离开来，这些实现细节定义了GUI如何发现（并可能适应）特定平台上的设置。

LookAndFeel类的完整实现可以在LookAndFeel.cpp文件中找到。 当前的实现非常简单。 LookAndFeel类提供了一种用于标准化GUI外观的机制，但是不存在允许用户自定义应用程序的实现。 第8章简要建议可以对LookAndFeel类进行一些可能的扩展，以使pdCalc用户可自定义。

### 6.9 A Working Program

在本章结束时，将使用一个可运行的main（）函数来启动GUI。 由于您在第7章中会遇到其他要求，因此pdCalc的实际main（）函数要比下面列出的函数复杂得多。 但是，该简化版本值得一列举，以说明如何将pdCalc的组件与GUI绑定在一起，以创建可运行的独立可执行文件。 参见清单6-7。

```c++
int main(int argc, char* argv[])
{
    QApplication app{argc, argv};
    MainWindow gui{argc, argv};
    CommandDispatcher ce{gui};
    RegisterCoreCommands(gui);
    gui.attach( UserInterface::CommandEntered,
    make_unique<CommandIssuedObserver>(ce) );
    Stack::Instance().attach( Stack::StackChanged,
    make_unique<StackUpdatedObserver>(gui) );
    gui.setupFinalButtons();
    gui.show();
    gui.fixSize();
    return app.exec();
}
```

请注意，用于执行上述GUI的main（）函数与用于执行第5章结论中列出的CLI的main（）函数之间的相似之处。相似之处并非偶然，而是pdCalc模块化设计的结果。

与CLI一样，为使您快速入门，存储库源代码中包含一个项目，该项目使用上述main（）函数作为应用程序的驱动程序来构建可执行文件pdCalc-simple-gui。 可执行文件是一个独立的GUI，其中包括本书中到目前为止所讨论的所有功能。

在结束本节之前，我将对上面的实现进行一些评论。首先，在gui上调用show（）的QApplication类和app.exec（）调用都是样板Qt代码。就像我们在这里所关心的那样，这些调用使我们能够启动GUI并将其显示在屏幕上。其次，在gui上调用setupFinalButtons（），但我们从未将此函数定义为MainWindow界面的一部分。需要此功能才能在存在插件的情况下正确添加按钮。使用本章设计的独立GUI，则不需要setupFinalButtons（）函数。我在上面的代码清单中包括了此函数，以便上面的main（）函数可以与现有的GitHub存储库代码一起使用。最后，fixSize（）函数也不包含在本章构建的接口中。此功能是实现细节，对GUI的设计没有任何贡献。该功能仅用于固定屏幕上GUI的大小并取消调整其大小的功能。同样，此功能的必要性是由插件引起的，因为我们只有在插件添加了按钮之后才能知道GUI的最终几何形状。

### 6.10 A Microsoft Windows Build Note

pdCalc设计为既是GUI又是CLI。 在Linux中，控制台应用程序（CLI）和窗口应用程序（GUI）之间不存在编译时区别。 可以为两种样式使用相同的构建标志来编译统一的应用程序。 但是，在Microsoft Windows中，创建同时充当CLI和GUI的应用程序并不是一件容易的事，因为操作系统要求应用程序在编译期间声明控制台或Windows子系统的使用情况。

为什么在Windows上子系统的声明很重要？ 如果某个应用程序被声明为窗口应用程序，则从命令提示符启动该应用程序时，该应用程序将简单地返回而没有任何输出（即，该应用程序看起来好像从未执行过）。 但是，当双击该应用程序的图标时，该应用程序将在没有后台控制台的情况下启动。 另一方面，如果将某个应用程序声明为控制台应用程序，则从命令提示符启动时将显示GUI，但是如果双击该应用程序的图标将其打开，则该GUI将使用后台控制台启动。

按照惯例，Microsoft Windows应用程序是为一个子系统或另一个子系统设计的。 在同时使用GUI和CLI开发应用程序的少数情况下，开发人员已经创建了避免上述问题的技术。 一种这样的技术创建了两个应用程序.com和.exe，操作系统可以根据通过命令行参数选择的选项来适当地调用它们。

为了保持pdCalc的代码简单和跨平台，我忽略了这个问题，只是在控制台模式下构建了GUI（但是，没有CLI的pdCalc-simple-gui是在窗口模式下构建的）。确实，这意味着如果应用程序是通过双重启动的，
点击pdCalc的图标，背景中会出现一个额外的控制台窗口。如果您打算主要将应用程序用作GUI，则可以通过简单地删除使用控制台的功能来解决该问题（例如，在pdCalc.pro构建文件中注释掉win32：CONFIG + = console行）。如果您需要同时访问CLI和GUI，并且多余的控制台让您发疯，则有两个现实的选择。首先，在Internet上搜索上述技术之一，然后尝试一下。就个人而言，我从未走过那条路。其次，构建两个单独的可执行文件（可能称为pdCalc和pdCalc-cli），而不是一个能够基于命令行参数切换模式的可执行文件。该应用程序的灵活体系结构可轻松支持任一决定。





